---
title: 《Google SRE》读后感
date: 2017-01-07 21:19
excerpt: "如果系统正常运转中需要人工干预，应该将此视为一种 BUG"
categories:
- history
- devops
- sre
feature_image: "/assets/static/img/content.jpg?image=872"
---
* 服务质量目标
  1. SLI:
     服务的量化指标
  2. SLO：
     服务的质量目标（如：SLI  <= SLO）
  3. SLA：
     达到或者未达到目标应该有什么样的措施（如：给用户退款）
     通常 SRE 并不需要关心 SLA，但应该尽可能告诉业务、法务部门 SLO 的难易度，并且给出 SLI
  /*可以在错误预算之内进行刻意的触发故障来判断哪些系统过于依赖不应该依赖的组件*/
** 指标的标准化
   1. 汇总间隔：每分钟汇总一次
   2. 汇总范围：集群中的全部任务
   3. 度量频率：每 10 秒一次
   4. 包含的请求：从黑盒监控任务发来的 HTTP GET 请求
   5. 数据获取：通过监控系统获取服务器端信息得到
   6. 数据访问延迟：从收到请求最后一个字节被发出
** 目标范围
   从想要的（用户视角）目标反向推导出具体的指标。
** 目标的选择
   1. 不要仅以当下的状态为基础选择目标
   2. 保持简单
   3. 避免绝对值
   4. SLO 越少越好，保证每一个目标都是必须的
   5. 不要追求完美
* 琐事
  /*如果系统正常运转中需要人工干预，应该将此视为一种 BUG*/
* 监控
** 4 个黄金指标
   1. 延迟：
      区分成功、失败的延迟
   2. 流量
      如：内存、IO、HTTP 的每秒请求数等
   3. 错误
      请求失败的速率，感觉和 第一条 重复了，不太理解
   4. 饱和度
      如：该系统是否可以承担额外的 10%、50% 的流量
** 长尾问题
   如访问速度，按监控值分组，比如：0 ~ 10ms 之间的数量，30 ~ 100ms 之间的数量，100ms 以上的数量，等等
** 精简监控平台
   1. 最能反映真实故障的规则应该越简单越好，可预测性强，非常可靠
   2. 不常用的数据收集、汇总，以及警报配置应该定时删除（如一个季度没有用到一次即将其删除）
   3. 收集到的信息没有暴露给任何监控台，或者被任何警报规则使用的应该定时删除
** 设计一个监控系统的 checklist
   1. 该规则 是否能够检测到一个目前检测不到的、紧急的、有操作性的，并且即将发生或者已经发生的用户可见故障
   2. 是否可以忽略这条报警？什么情况可能会导致用户忽略这条警报？如何避免？
   3. 这条警报是否确实显示了用户正在受到影响？是否存在用户没有受到影响也可以出发这条规则的情况？例如
      测试环境和系统维护状态下发出的警报是否应该被过滤掉？
   4. 收到警报后，是否要进行某个操作？是否需要立即执行该操作，还是可以等到第二天早上再进行？该操作是否可以被安全地自动化？
      该操作的效果是长期的还是短期的？
   5. 是否也会有其他人收到相关的紧急警报，这些紧急警报是否是不必要的？
* Google 的自动化系统演进
** 自动化的价值
   1. 一致性
      任何机械、重复的行为都不可能永远复制成功方式的步骤，这个是自动化的首要价值。
   2. 平台性
      1) 错误集中化，一次变更永久修复
      2) 方便扩展
      3) 梳理流程
   3. 修复速度
      降低故障的平均修复时间，可以把时间用来防止其他故障的自动化处理，良性循环
   4. 行动速度更快
   5. 节省时间
      自动化设施可以被所有人使用
*** 自动化实现路径
    1. 操作人员手动触发操作（无自动化）
    2. 操作人员编写系统特定的自动化
    3. 外部维护的通用自动化
    4. 内部维护，系统特定的自动化
    5. 不需要认为干预的自治系统
* 发布工程
** 发布工程哲学
   1. 自服务模型
      完全自动化，不需要人工干预，自动构建、自动发布
   2. 追求速度
      业务产品相关，测试通过即自动发布
   3. 密闭性
      1) 不同环境构建结果应该一致
      2) 构建环境和产品代码绑定，即：如果要对上个月构建过的产品加入一些新功能重新构建，则仍旧使用上个月构建时的环境，包括编译器、依赖库等
   4. 强调策略和流程
      1) 批准源代码改动——功过源代码仓库中的配置文件决定
      2) 指定发布流程中需要执行的具体操作
      3) 创建新的发布版本
      4) 批准初始的集成请求(也就是一个以某个源代码仓库版本为基础的构建请求)，以及后续的 cherry picking 请求
      5) 实际部署某个发布版本
      6) 修改某个项目的构建配置文件
   5. 结果归档，包括构建过程
** 持续构建与部署
*** Rapid，Google 内部开发并使用的发布系统
    1. 构建
       1) 提供需要的依赖，rapid 完成依赖安装
       2) 二进制文件中提供构建时间、构建版本等标识符
    2. 分支
       从 mainline 中分离线上版本（如 git tag）
    3. 测试
       自动单元测试，测试结果归档并且审核后发布
    4. 打包
       构建结果做 HASH，并且加入签名，防止结果被改动。
    5. 配置文件与产品版本关联，同时测试、发布等
** END
   1. 发布工具(或其他工具)的开发是因为需要针对自己团队的流程
   2. 项目初期定义发布规范，而不是在由开发团队编写代码后“将结果扔过墙”
* 简单化
  一个对 SRE 管理系统的方法不错的总结是“我们的工作最终是在系统的灵活性和稳定性上维持平衡”

  SRE 通过创造流程、实践与工具来提高软件的可靠性。同时最小化这些流程、工具对开发人员的灵活性
  造成的影响。
** 乏味是一种美德
   必要复杂度和意外复杂度，必要复杂度是不可避免的，预料中的；意外复杂度是可以通过设计来使其更简单的。

   为了最小化意外复杂度，SRE 团队应该：
   1. 在他们所负责的系统中引入意外复杂度时及时提出抗议。
   2.不断地努力消除正在接手的和已经负责运维的系统的复杂度。

   这里我想到的就是，在我目前的生产环境中用到了很多软链接，虽然我努力做了一些抗议，但没有被接受。